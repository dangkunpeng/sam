
## IAP总结

### 1.数据库短连接
#### 1.1 问题：一个接收数据的接口偶尔会出现死锁，需要人为干预才可以继续流程
#### 1.2 原因：接口操作数据库长时间不释放资源，跟用户操作产生冲突

### 1.3 最佳实践点
##### 1.3.1 分析业务，剥离非核心业务，
~~~
把非核心数据的数据库操作放到新的队列里去，减少主线程的时间
~~~
##### 1.3.2 把所有的数据库修改操作放到最后，一起提交，减少主线程等待时间
##### 1.3.3 把查询放到循环外面，
~~~
for循环里只对数据对象做操作，循环结束批量更新数据库
~~~
##### 1.3.4 简化非必要查询，
~~~
剥离字典类型的查询，把目标数据放到Java中遍历，使用缓存里的字典对象进行字典处理
~~~
##### 1.3.5 尽量使用主键进行更新操作，减少锁表对象
##### 1.3.6 避免大SQL，考虑查询时尽量减少多表关联查询
##### 1.3.7 跟外部接口交互时，考虑异步并发编程
##### 1.3.8 合理设置索引
### 2.保证队列消息不丢失
#### 2.1 消息发送到交换机丢失 : 发布者确认机制publisher-confirm
~~~
消息发送到交换机失败会向生产者返回ACK , 生产者通过回调接收发送结果 , 
如果发送失败, 重新发送, 或者记录日志人工介入
~~~
#### 2.2 消息从交换机路由到队列丢失 : 发布者回执机制publisher-return
~~~
消息从交换机路由到队列失败会向生产者返回失败原因 , 生产者通过回调接收回调结果 , 
如果发送失败, 重新发送, 或者记录日志人工介入
~~~
#### 2.3 消息保存到队列中丢失 : MQ持久化(交换机持久化, 队列持久化 , 消息持久化)
#### 2.4 消费者消费消息丢失 : 消费者确认机制 , 消费者失败重试机制
#### 2.5 设计一个消息状态表 , 
~~~
主要包含 : 消息id , 消息内容 , 交换机 , 消息路由key , 发送时间, 签收状态等字段 , 
1.发送方业务执行完毕之后 , 向消息状态表保存一条消息记录, 消息状态为未签收 , 
2.之后再向MQ发送消息 , 消费方接收消息消费完毕之后 , 向发送方发送一条签收消息 , 
3.发送方接收到签收消息之后 , 修改消息状态表中的消息状态为已签收 ! 
4.之后通过定时任务扫描消息状态表中这些未签收的消息 , 重新发送消息, 直到成功为止 , 
5.对于已经完成消费的消息定时清理即可 
~~~

### 3.RabbitMQ如何保证消息的幂等性
如何保证消息队列消费的幂等性，这一块应该还是要结合业务来选择合适的方法，有以下几个方案：#
#### 3.1 消费数据为了单纯的写入数据库，
~~~
可以先根据主键查询数据是否已经存在，如果已经存在了就没必要插入了。
或者直接插入也没问题，因为可以利用主键的唯一性来保证数据不会重复插入，重复插入只会报错，但不会出现脏数据。
~~~
#### 3.2 消费数据只是为了缓存到redis当中，这种情况就是直接往redis中set value了，天然的幂等性。
#### 3.3针对复杂的业务情况，
~~~
可以在生产消息的时候给每个消息加一个全局唯一ID，
消费者消费消息时根据这个ID去redis当中查询之前是否消费过。
如果没有消费过，就进行消费并将这个消息的ID写入到redis当中。
如果已经消费过了，就无需再次消费了。
~~~